---
title: "Scrap and clean episode transcripts"
output: html_notebook
---

Aim:
* Scrap and clean episode transcripts from genius.com;
* Relate all characters that were scrapped in script '02_scrap_characters_list.Rmd' to those in transcripts.

```{r eval=TRUE, warning=FALSE, message=FALSE}
rm(list = ls())

library(httr)
library(tidytext)
library(knitr)
library(xml2)
library(rebus)
library(stringr)
library(rvest)
library(magrittr)
library(tidyverse)

```


#Import data from previous scripts
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.dead <- readRDS("interim_output/characters.death.long.02.RDS")

characters.all <- readRDS("interim_output/characters.all.02.RDS")

```

#Scrap list of GoT episodes
```{r eval=TRUE, warning=FALSE, message=FALSE}

if(!"episode_list.RDS" %in% list.files("interim_output/")){
  
episode.list <- read_html("https://en.wikipedia.org/wiki/List_of_Game_of_Thrones_episodes")

episode.list %<>%
  html_nodes( ".summary") %>%
  html_text() %>%
  str_replace_all(pattern = rebus::or("[[:punct:]]", "[[:cntrl:]]"),
                  replacement = "")

episode.list %>%
  write_rds("interim_output/episode_list.RDS")

}else{
  
episode.list <- read_rds("interim_output/episode_list.RDS")  
  
}

```

# Scrap GoT transcripts from genius.com
There seem to be two different patterns in the links of genius.com
Ones end with 'script-annotated' and others just with 'annotated'.
e.g. "https://genius.com/Game-of-thrones-episode-annotated" and "https://genius.com/Game-of-thrones-episode-script-annotated"

## Create hypothetical links to transcript websites

```{r eval=TRUE, warning=FALSE, message=FALSE}

links.all.seasons.1 <- episode.list %>%
  tolower() %>%
  str_replace_all(pattern = " ", replacement = "-") %>%
  str_c("https://genius.com/Game-of-thrones", ., "annotated", sep = "-")

links.all.seasons.2 <- episode.list %>%
  tolower() %>%
  str_replace_all(pattern = " ", replacement = "-") %>%
  str_c("https://genius.com/Game-of-thrones", ., "script","annotated", sep = "-")

links.all.seasons.df <- data_frame(link_1 = links.all.seasons.1,
                                   link_2 = links.all.seasons.2)

```


## Check if links are valid 
Not all episodes are transcribed in genius.com webpage!
Spot missing transcribed episodes.
_To update list of transcripts, delete the output of this chunk of code and run it_
```{r eval=TRUE, warning=FALSE, message=FALSE}

if(!"valid_transcript_links.RDS" %in% list.files("interim_output")){

valid.links.1 <- links.all.seasons.df$link_1 %>%
  map_lgl(url_success) 

valid.links.2 <- vector(mode = "logical", length = length(valid.links.1))

valid.links.2[valid.links.1 == F] <- links.all.seasons.df$link_2[valid.links.1 == F] %>%
  map_lgl(url_success)
  
links.all.seasons.df %<>%
  bind_cols(valid_links_1 = valid.links.1,
            valid_links_2 = valid.links.2)

valid.links <- if_else(links.all.seasons.df$valid_links_1 == T,
                       true = links.all.seasons.df$link_1,
                       false = if_else(links.all.seasons.df$valid_links_2 == T,
                                       true = links.all.seasons.df$link_2,
                                       false = "missing episode"))

valid.links %>%
  write_rds(path = "interim_output/valid_transcript_links.RDS")

}else{
  
  valid.links <- read_rds(path = "interim_output/valid_transcript_links.RDS")
  
}

```

**06-10-2017 There seem to be 22 episodes missing!** 
```{r eval=TRUE, warning=FALSE, message=FALSE}

(valid.links == "missing episode") %>% sum()

valid.links

```

## Scrap transcripts
```{r eval=TRUE, warning=FALSE, message=FALSE}

season.vector <- c(str_c("season_", rep(1:6, 10)), rep("season_7", 7)) %>% sort

episode.number.vector <- c(rep(1:10, 6), rep(1:7))

episode.list.df <- data_frame(season = season.vector,
                              episode_number = episode.number.vector,
                              episode_name = episode.list,
                              link = valid.links)

episode.list.df

rm(valid.links, season.vector, episode.number.vector, links.all.seasons.1, links.all.seasons.2,
   links.all.seasons.df, episode.list)

```

## Convert trantscripts into tidy text
```{r eval=TRUE, warning=FALSE, message=FALSE}

if(!"all_transcripts.RDS" %in% list.files("interim_output/")){

all.transcripts <- episode.list.df$link[which(episode.list.df$link != "missing episode")] %>%
  map(function(x){read_html(x) %>%
  html_nodes(".lyrics p") %>%
  html_text })

 all.transcripts %>% 
   write_rds(path = "interim_output/all_transcripts.RDS")
 
}else{
  
  all.transcripts <- read_rds("interim_output/all_transcripts.RDS")
  
}
 
```


```{r eval=TRUE, warning=FALSE, message=FALSE}

all.transcripts %<>%
  map_chr(function(x){x %>% unlist %>% str_c(collapse = "_") })

episode.list.df$transcript <- NA

episode.list.df$transcript[episode.list.df$link != "missing episode"] <- all.transcripts


```

###Transcripts into readable text
This step is not strictly needed but it helps manual explorations and checks.
**Not finished**
```{r eval=FALSE, warning=FALSE, message=FALSE}

if(!"interim_output/transcripts" %in% list.dirs("interim_output/transcripts")){
  
  dir.create("interim_output/transcripts")
  
}

#for(i in 1:nrow(episode.list.df)){
  
 # episode.list.df
  
#}

trial <- episode.list.df[1:3,] %>% #place a conditional to use only those that have valid transcripts
  transpose() %>%
  map(function(x){ 
    
    x$transcript %>%
      strsplit(split = rebus::or("\n", "." %R% "[[:upper:]]+" ) ) %>%
      unlist() %>% 
      #data_frame() %>% 
      print()
      #write_delim(path = str_c("interim_output/transcripts/","transcript_", x$episode_name, ".txt"),
       #           delim = "\t")
    
      }) 
  

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

rm(all.transcripts)

```

#Spot character names in transcripts
Transcriptions use names both in upper and lower case! 
e.g. 
* https://genius.com/Game-of-thrones-winter-is-coming-annotated
* https://genius.com/Game-of-thrones-the-kingsroad-annotated

Ideally, the pattern used should also be able to capture all names in characters scraped from wikipedia (i.e. object: characters.all).

There are some transcripts that use \ n pattern, others that don't

There are patterns of 'NAME (in valerian)' e.g:
'CERSEI (sighs): Thank you so much for your kind words'.

Names can have one or multiple words.

```{r eval=TRUE, warning=FALSE, message=FALSE}

pattern.character.names <- rebus::or("\\.[[:alpha:]]+" %R% rebus::one_or_more(" [[:alpha:]]+") %R% ":",
                                     "\n[[:alpha:]]+" %R% rebus::one_or_more(" [[:alpha:]]+") %R% ":",
                                     "\n[[:alpha:]]+" %R% rebus::zero_or_more(" [[:alpha:]]+") %R% " \\(" %R% rebus::one_or_more(rebus::or("[[:alpha:]]","\\s")) %R% "\\):",
                                     "\\.[[:alpha:]]+" %R% rebus::zero_or_more(" [[:alpha:]]+") %R% " \\(" %R% rebus::one_or_more(rebus::or("[[:alpha:]]","\\s")) %R% "\\):")

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts <- episode.list.df$transcript %>%
  str_extract_all(pattern = pattern.character.names) %>%
  unlist %>% str_replace_all(pattern = rebus::or(":", "\n", "\\.", 
                                                 "\\(" %R% rebus::one_or_more("[[:print:]]") %R% "\\)"), replacement = "") %>% 
  unique %>% 
  sort

rm(pattern.character.names)

```

All characters in transcripts to upper. This is not the final list and should be further cleaned! 
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts %<>%
  toupper() %>% 
  str_trim(side = "right") %>%
  unique

characters.transcripts

```


# Clean names in transcritpts

## Do a quick clean of characters in transcripts

Delete prefix such as: 'young', 'lady', 'maester', 'ser' and 'lord'.
Careful with:
* Removing pattern 'SER ' would cut the end of 'ALLISER';
* Removing pattern 'LADY ' would also remove it from 'LADY CRANE', which exists in the list of all characters;
* Removing pattern 'LORD ' would also remove it from 'LORD OF BONES', which exists in the list of all characters. Removing pattern 'LORD' also causes confusion as we can latter not distinguish between 'LORD KARSTARK' (i.e. Rickard Karstark) and Harald Karstark (named as 'Karstark' in season 6). Removing the same pattern in 'LORD MORMONT' makes it impossible to distinguish between 'Jeor Mormont' (aka Lord Mormont) and 'Jorah Mormont';
* Removing pattern 'YOUNG' creates confusion as 'YOUNG LYANNA' (i.e. Lyanna Stark) gets the same name as 'LYANNA' (i.e. Lyanna Mormont).

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts %>%
  str_subset(pattern = rebus::or("LORD ", "MAESTER ",
                                 "SER ", "YOUNG ", #careful when removing SER!
                                 "LADY ", # Lady Crane exists in the wikipedia list! Can not blindly remove LADY.
                                 "GRAND")) %>%
  sort
  
```

We will skip those rows when when removing the patterns.
```{r eval=TRUE, warning=FALSE, message=FALSE}

name. <- vector(mode = "character", length = 1)

error.sources.pattern. <- rebus::or("LADY CRANE", "ARCHMAESTER",
                                    "LORD OF BONES", "LORD KARSTARK",
                                    "YOUNG LYANNA", "LORD MORMONT")

for(i in seq_along(characters.transcripts)){
  
  name. <- characters.transcripts[i]
  
  if(name. %>% str_detect(pattern = error.sources.pattern.)){
    
    next()
  
  }else{
      
    characters.transcripts[i] %<>%
      str_replace_all(pattern = rebus::or("LORD ", "MAESTER ",
                                                         "^SER ", "YOUNG ",
                                                         "LADY ", "LADYC "),
                                     replacement = "")
    }
  
}

characters.transcripts %<>% 
  sort 

characters.transcripts

rm(name., error.sources.pattern., i)

```


Delete objects which are obviously not characters
```{r eval=TRUE, warning=FALSE, message=FALSE}

delete.non.characters <- c("A VOICE", "ALL", "ALL THREE", "ALL TOGETHER", 
                           "ANNOUNCER", "ANNOUNCER ",
  "ARCHERS", "ARYA TURNS AND EXITS THE INNCUT TO", "ASSASSIN", "ATTENDANT", 
  "BANKER", "BLACK HAIRED PROSTITUTE", "BLONDE PROSTITUTE", "BOLTON BANNERMAN",
  "BOLTON OFFICER", "BOTH JON AND SAM", "BOY","BRAAVOSI MAN", "BROTHEL KEEPER",
  "BROTHER", "BROTHERS", "BUER", "BUYER", "BYSTANDERS", "CAPTAIN", "CHILD OF THE FOREST",
  "CLIENT", "CROWD", "CUT TO", "DAUGHTER", "DOTHRAKI MAN", "DOTHRAKI MATRON", 
  "DOTHRAKI WOMAN", "EVERYONE", "FREY GUARD", "GIANT", "GIRL", "GLOVER", 
  "GOLD CLOAK", "GUARD", "GUARD CAPTAIN", "HANDMAIDEN", "HARPY ", "HEAD", 
  "HEAD PROSTITUTE", "HOODED FIGURE", "HUNTERS", "KINGS GUARD", "KINGSGUARD",
  "KNIGHT", "KNIGHT OF HOUSE BRACKEN", "LANNISTER SCOUT", "LANNISTER SOLDIER ",
  "LEADER", "LISTENERS ", "BOLTON", "MAID", "MAN", "MASTER", "MASTER OF ARMS",
  "MEN", "MERCHANT", "MESSENGER", "MISTRESS", "OFFICER", "OLD MAN", "OWNER", "PLEASE NOTE", 
  "POPULACE", "PRIEST", "PRIESTESS", "PROSTITUTE", "RED PRIEST", "RED PRIESTESS", 
  "REMEMBER THIS", "RIDER", "SLAVE BUYER", "SLAVE OWNER", "SLAVER", "SOLDIER",
  "SPARROW", "SQUIRE", "STABLE BOY", "STARK GUARD", "STEWARD", 
  "STEWARD OF HOUSE STARK", "STORYTELLER", "STRONG", "SURVIVOR",
  "TELL ME SOMETHING", "THE GROUP", "THE OTHERS AT THE TABLE", 
  "THEON COVERS THE MAP WITH PAWNSGREATJON UMBER", "THIN MAN", "TOGETHER",
  "TRIBESMEN OF THE VALE", "VOICES OUTSIDE", "WAITRESS", "WATCHMAN",
  "WILDLING", "WILDLING ELDER", "WINE MERCHANT", "WOMAN", "MAN") %>%
  str_trim(side = "right") %>%
  unique()

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts <- characters.transcripts[!characters.transcripts %in% delete.non.characters]

```

**Create a data frame that maps the original names that appear in the transcripts with their cleaned version**
Orignal names contain spelling mistakes or different versions of the name than those in the scrapped wikipedia list.
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts.df <- data_frame(characters.transcripts.original = characters.transcripts,
                                        characters.transcripts.cleaned = characters.transcripts)



rm(characters.transcripts)

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts.df$characters.transcripts.cleaned %>%
  str_subset(pattern = "AERSON")

```


**Create table with replacements**

```{r eval=TRUE, warning=FALSE, message=FALSE}

original. <- c(rebus::or("ALLITHORNE", "ALLITHRONE", "ALLISTER"),
               rebus::or("BAELISH", "LITTLEFINGER"),
               "BLACK WALDER",
               "BLACKFISH",
               "BRAND",
               "BRIENNE",
               "CASSEL",
               rebus::or("DAERNEYS", "DANERYS"),
               rebus::or("DARIO", "DARRIO"),
               rebus::or("DOLOROUS EDD", "EDDARDDISON TOLLETT"),
               rebus::or(exactly("ED"), exactly("EDD"), exactly("EDDARDD")),
               rebus::or("ELARIA", "ELLIA"),
               "EYED RAVEN",
               "GREYWORM",
               rebus::or("PYCELL", "PYRCELLE", "PYCELLEE"),
               "MELISDANDRE",
               "MHAEGAN",
               "MOSADOR",
               "MOUNTAIN",
               "OLEANNA",
               "OTHELL YARWICK",
               rebus::or("SAM", "SAMMY"),
               "SAAN",
               "QYBURNS",
               "RAMSEY",
               "ROZ",
               "SLYNT",
                rebus::or("THE HOUND","HOUND"),
               "LORD KARSTARK",
               "YOUNG LYANNA",
               "LADYC RANE",
               "LORD MORMONT")

replacement. <- c("ALLISER THORNE",
                  "PETYR BAELISH",
                  "BLACK WALDER RIVERS",
                  toupper("Brynden Tully"),
                  "BRAN",
                  "BRIENNE OF TARTH",
                  "RODRIK CASSEL",
                  "DAENERYS",
                  toupper("Daario Naharis"),
                  "EDDISON TOLLETT",
                  "EDDARD",
                  "ELLARIA SAND",
                  "THREE-EYED RAVEN",
                  "GREY WORM",
                  "PYCELLE",
                  "MELISANDRE",
                  "MHAEGEN",
                  "MOSSADOR",
                  "GREGOR CLEGANE",
                  "OLENNA",
                  "OTHELL YARWYCK",
                  "SAMWELL TARLY",
                  "SALLADHOR SAAN",
                  "QYBURN",
                  "RAMSAY",
                  "ROS",
                  "JANOS SLYNT",
                  "SANDOR CLEGANE",
                  "RICKARD KARSTARK",
                  "LYANNA STARK",
                  "LADY CRANE",
                  "JEOR MORMONT")

replacements <- data_frame(original = original., replacement = replacement.)

rm(original., replacement.)

```

Check that all original. words are in original transcripts.

**TO DO: Did I not capture 'Eyed raven' this time?**
```{r eval=TRUE, warning=FALSE, message=FALSE}

for(i in 1:nrow(replacements)){
  
  replacements$original[i] %>% print()
  
  str_detect(characters.transcripts.df$characters.transcripts.original, replacements$original[i]) %>%
    sum() %>% print()
  
}

rm(replacements, i)

```


Clean characters from transcripts
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts.df %>%
  mutate(characters.transcripts.cleaned = characters.transcripts.cleaned %>%
           str_replace(pattern = "AERSON", replacement = "AERON"))

characters.transcripts.df %<>%
  unique()

```




# Match characters in transcripts to all names in previous scripts

## Create numeric identifiers for  character names which appeared in previous scripts

Create a data frame with wikipedia/all character names with an identifier
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.all.map.df <- data_frame(character.names.wikipedia = characters.all %>% toupper() %>% sort(),
           identifier = 1:length(characters.all))

characters.all.map.df %>%
  write_csv("interim_output/characters_all_map.csv")

rm(characters.all)

```

## Try to match exact 

Percentage of cases matching
```{r eval=TRUE, warning=FALSE, message=FALSE}

(characters.all.map.df$character.names.wikipedia %in% characters.transcripts.df$characters.transcripts.cleaned) %>% sum()/nrow(characters.all.map.df)

```

Matched cases
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.all.map.df %>% 
  filter(character.names.wikipedia %in% characters.transcripts.df$characters.transcripts.cleaned) %$%
  character.names.wikipedia %>% head()

```

Unmatched cases
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.all.map.df %>% 
  filter(!character.names.wikipedia %in% characters.transcripts.df$characters.transcripts.cleaned) %$%
  character.names.wikipedia %>% head()

```


## Suggest matches by first name

For unmatched characters, try matching by first name. These matches should be checked manually. This is because some first names apply to multiple characters 
(e.g. Kahl Brozho, Kahl Frozho)

In transcripts, many characters appear only with their first name (i.e. last name is excluded). We need to compute the first name of all characters and match the names in transcripts with either first name or full name

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.all.firstname <- characters.all.map.df$character.names.wikipedia %>%
  str_match(pattern = capture("[[:upper:]]+") %R% optional(" " %R% "\\w+") %R% " [[:upper:]].+") %>% .[,2]

characters.all.map.df %<>%
  bind_cols(characters.all.firstname = characters.all.firstname)

```


Eliminate repeated first names. It would be dangerous to match them.
```{r eval=TRUE, warning=FALSE, message=FALSE}

repeated.first.names <- characters.all.map.df %>%
  count(characters.all.firstname) %>%
  filter(n > 1, !is.na(characters.all.firstname)) %>%
  arrange(desc(n))

repeated.first.names

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.all.map.df %<>%
  mutate(characters.all.firstname = if_else(!characters.all.firstname %in% repeated.first.names$characters.all.firstname,
                                            true = characters.all.firstname,
                                            false = NA_character_ ) )

```

Try to match with full name OR only first name
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.all.map.df

characters.transcripts.df %>% head

```


**To do: It still misses some like ALLISER THRONE, Cersei Baratheon or   **
Overall, it's a great improvement. Manually check. Then export those that are not matched and do it manually.

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts.df %<>%
  left_join(characters.all.map.df %>% select(character.names.wikipedia, identifier), 
            by = c("characters.transcripts.cleaned"="character.names.wikipedia") ) %>%
  rename(identifier_fullname = identifier) %>%
  left_join(characters.all.map.df %>% select(characters.all.firstname, identifier),
            by = c("characters.transcripts.cleaned"="characters.all.firstname")) %>%
  rename(identifier_firstname = identifier)

characters.transcripts.df

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts.df %<>%
  mutate(identifier = if_else(!is.na(identifier_fullname), 
                              true =  identifier_fullname,
                              false = identifier_firstname
         )) %>%
  select(-identifier_fullname, -identifier_firstname)

characters.transcripts.df

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts.df %$% identifier %>% is.na() %>% sum()

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts.df %>%
  filter(is.na(identifier)) %>%
  write_csv("interim_output/characters_manually_match.csv")

```

## Check where unmatched/ambiguous characters appear
```{r eval=TRUE, echo = FALSE, warning=FALSE, message=FALSE}

episode.list.df$transcript %>%
  map_lgl(function(x){str_detect(x, rebus::or("Arryn: ","ARRYN: ") )}) %>% 
  unlist() %>% 
  which()

episode.list.df$transcript %>%
  map_lgl(function(x){str_detect(x, rebus::or("Jon: ","JON: ") )}) %>% 
  unlist() %>% 
  which()

```

```{r eval=TRUE, echo = FALSE, warning=FALSE, message=FALSE}

episode.list.df$transcript %>%
  map_lgl(function(x){str_detect(x, rebus::or("KARSTARK: ","Karstark: ") )}) %>% 
  unlist() %>% 
  which()

episode.list.df$transcript %>%
  map_lgl(function(x){str_detect(x, rebus::or("KARSTARK: ","Karstark: ") )}) %>% 
  unlist() %>% 
  which() %>%
  episode.list.df$link[.]


```

```{r eval=TRUE, echo = FALSE, warning=FALSE, message=FALSE}

episode.list.df$transcript %>%
  map_lgl(function(x){str_detect(x, rebus::or("LYANNA MORMONT: ","Lyanna Mormont: ") )}) %>% 
  unlist() %>% 
  which() 

episode.list.df$transcript %>%
  map_lgl(function(x){str_detect(x, rebus::or("LYANNA: ","Lyanna: ") )}) %>% 
  unlist() %>% 
  which() 

```


It looks like the mention to 'ROYCE' in the first episode refers to 'WAYMAR ROYCE' and those in episoded 38, 41, 54, 62 refer to 'YOHN ROYCE'. That's great.
```{r eval=TRUE, echo = FALSE, warning=FALSE, message=FALSE}

episode.list.df$transcript %>%
  map_lgl(function(x){str_detect(x, rebus::or("ROYCE: ","Royce: ") )}) %>% 
  unlist() %>% 
  which() 

episode.list.df$transcript %>%
  map_lgl(function(x){str_detect(x, rebus::or("WAYMAR ROYCE: ","Waymar Royce: ") )}) %>% 
  unlist() %>% 
  which() 

episode.list.df$transcript %>%
  map_lgl(function(x){str_detect(x, rebus::or("ROBAR ROYCE: ","Robar Royce: ") )}) %>% 
  unlist() %>% 
  which() 

episode.list.df$transcript %>%
  map_lgl(function(x){str_detect(x, rebus::or("YOHN ROYCE: ","Yohn Royce: ") )}) %>% 
  unlist() %>% 
  which() 

```



3825f45v5d

## Import back the transcript characters which were manually matched
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.manually.matched <- read_delim("interim_output/characters_manually_match_MOD.csv",
                                        delim = ";")

```

### New characters to add to the wikipedia list
These are characters that appeared in the transcripts but not in the wikipedia list. We should add them to the list scrapped from wikipedia (i.e. characters.all). 
```{r eval=TRUE, warning=FALSE, message=FALSE}

next.current.identifier <- characters.all.map.df$identifier %>%
  max()+1

number.new.added <- characters.manually.matched %>%
  filter(comment == "add as new character") %>%
  nrow()

added.characters <- characters.manually.matched %>%
  filter(comment == "add as new character") %>%
  select(new_name) %>%
  mutate(character.names.wikipedia = toupper(new_name),
         identifier = next.current.identifier:(next.current.identifier+number.new.added-1),
         characters.all.firstname = NA_character_) %>%
  select(-new_name)

characters.all.map.df %<>%
  bind_rows(added.characters)

rm(next.current.identifier, number.new.added)

```

### Characters to delete from transcripts
These were spot as characters from transcripts but are not. They should be deleted.
```{r eval=TRUE, warning=FALSE, message=FALSE}

deleted.characters <- characters.manually.matched %>%
  filter(comment == "delete") %>%
  select(characters.transcripts.cleaned)

characters.transcripts.df %<>%
  anti_join(deleted.characters) 

rm(deleted.characters)

```

### Character identifiers to update after manual check

With manual checks we imputed identifiers to match wikipedia scrapped characters (characters.all.df) with those in the transcripts (characters.transcripts.df)

Need to add new names and identities for those that were added after the manual review. 
```{r eval=TRUE, warning=FALSE, message=FALSE}

matched.characters <- characters.manually.matched %>%
  mutate(characters.transcripts.cleaned_new = if_else(comment == "add as new character",
                                                  true = toupper(new_name),
                                                  false = characters.transcripts.cleaned)) %>%
  rename(identifier_new = identifier) %>%
  filter(is.na(comment) | comment != "delete") %>%
  select(characters.transcripts.original, 
         characters.transcripts.cleaned_new, identifier_new)

characters.transcripts.df %<>%
  left_join(matched.characters, by = "characters.transcripts.original") %>% #cleaned have been modified. match with original
  mutate(identifier = if_else(!is.na(identifier),
                              true = identifier,
                              false = identifier_new),
         characters.transcripts.cleaned = if_else(!is.na(characters.transcripts.cleaned_new),
                                                  true = characters.transcripts.cleaned_new,
                                                  false = characters.transcripts.cleaned)) %>% select(-characters.transcripts.cleaned_new, -identifier_new)

characters.transcripts.df

```


Fill identifier for those that were added to the wikipedia list. Do this by merging characters.transcripts with wikipedia characters (characters.all) 

```{r eval=TRUE, warning=FALSE, message=FALSE}

added.characters

characters.transcripts.df %>%
  filter(is.na(identifier))

(!characters.transcripts.df %>%
  filter(is.na(identifier)) %$%
  characters.transcripts.cleaned  %in% added.characters$character.names.wikipedia) %>%
  which()

characters.all.map.df

```
We will probably not need first names any more
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.all.map.df %<>% select(-characters.all.firstname)

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts.df %<>%
  left_join(characters.all.map.df %>% rename(identifier_wikipedia = identifier),
            by = c("characters.transcripts.cleaned" = "character.names.wikipedia") ) %>%
  mutate(identifier = if_else(is.na(identifier) & !is.na(identifier_wikipedia),
                              true = identifier_wikipedia,
                              false = identifier)) 
  

characters.all.map.df 

characters.transcripts.df
```

Clean all objects that we're not gonna use
#rm(added.characters)



Carefull, double-check recodes in MOD interim_output file. I think ids might have moved after not removing certain patterns.

Check which characters from wikipedia do not appear in transcripts

Good news and bad news. IDs might not have moved but non-deleted patterns do not appear in wikipedia nor transcripts

These guys shouldn't exist because they were replaced

Impute id = 207 to RICKARD KARSTARK
LORD KARSTARK
LORD MORMONT
YOUNG LYANNA

```{r eval=TRUE, warning=FALSE, message=FALSE}

stop("Atura't")

```




## Do manual match for those that could not be matched automatically


**To do: I would still try to match as many first names as possible** 
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts.df %>%
  filter(is.na(identifier)) %>%
  write_csv("interim_output/characters_manually_match.csv")

```


```{r eval=TRUE, warning=FALSE, message=FALSE}

stop("Atura't")

```




#PREVIOUS SCRIPT

In transcripts, many characters appear only with their first name (i.e. last name is excluded). We need to compute the first name of all characters and match the names in transcripts with either first name or full name
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.all.firstname <- characters.all %>%
  str_match(pattern = capture("[[:upper:]][[:lower:]]+") %R% optional(" " %R% "\\w+") %R% " [[:upper:]].+")

# The previous regex fails to capture the first name of characters with names with three or more pieces such as:
# Brienne of Tarth; Hizdahr zo Loraq; Thoros of Myr
# I can do that with another regex.

characters.all.firstname.alternative <-characters.all %>%
  str_match(pattern = capture("[[:upper:]][[:lower:]]+") %R% " .+" %R%  " [[:upper:]].+")

characters.all.df <- data_frame(name_1 = characters.all, 
                                name_2 = characters.all.firstname[,2],
                                name_3 = characters.all.firstname.alternative[,2])

characters.all.df %<>%
  mutate(name_2 = if_else(is.na(name_2),
                          true = name_3,
                          false =name_2 )) %>%
  select(-name_3)

```




Salladhor Saan

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts.df$name[!characters.transcripts.df$name %in% 
                                 c(toupper(characters.all.df$name_1), toupper(characters.all.df$name_2))]

```

Optional: export unmatched character names to review them manually.
```{r eval=FALSE, warning=FALSE, message=FALSE}

characters.transcripts.df$name[!characters.transcripts.df$name %in% 
                                 c(toupper(characters.all.df$name_1), toupper(characters.all.df$name_2))] %>%
  as_data_frame %>% 
  write_excel_csv("interim_output/unmatched_names.csv")

```

Check duplicates in 'first name' that could have different 'first name' + 'last name'
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.all.df %>% head(10)

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

repeated.first.names <- characters.all.df %>%
  count(name_2) %>%
  filter(n > 1)

repeated.first.names

```

**Careful, there are repeated first names and these refer to different characters!**

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.all.df %>%
  filter(name_2 %in% repeated.first.names$name_2, !is.na(name_2)) %>%
  arrange(name_1)

rm(repeated.first.names)

```





Optional: import manually reviewed unmatched character names.
```{r eval=TRUE, warning=FALSE, message=FALSE}

unmatched <- read_delim("interim_output/unmatched_names_MOD.csv",
                        delim = ";") %>%
  filter(not_ignorable == 1) %$%
  value

unmatched

```


```{r eval=TRUE, warning=FALSE, message=FALSE}

map(episode.list.df$transcript, function(x){str_detect(x, pattern = "EDDARDDARDMURE")}) %>% unlist %>% which()

```



```{r eval=TRUE, warning=FALSE, message=FALSE}
stop("Atura't")
```

patterns to remove names: all , prostitute, EVERYBODY EVERYONE

"ALL"              
  [6] "ALL THREE"         "ALL TOGETHER"

"MELISANDRE"       
[191] "MELISDANDRE" MISSANDEI?

"ALLISER"           "ALLISER THORNE"    "ALLISER THRONE"   
 [11] "ALLISTER"
 
 
 "BRAN"              "BRAND"?
 
 CROWD
 
 "DAENERYS"          "DAERNEYS" "DANERYS"  

"DARIO"             "DARRIO" 


"ED"                "EDD"  NED STARK??             

"ELARIA"            "ELLARIA"          
 [86] "ELLIA"   
 
 
 BYSTANDERS
 
 
 GREY WORM  GREYWORM
 
  PLEASE NOTE	(out)  PYCELL PYCELLE
  
  
  QYBURN QYBURNS
  
  
  RAMSAY RAMSEY
  
  
The safest thing to do is to import a list of characters and try to match transcripts to these.
Then remove unmatched characters.

https://en.wikipedia.org/wiki/List_of_Game_of_Thrones_characters








  

Spot repeated character names with two words <- double-check this process
(i.e. they appear with name + lastname or only name)
```{r eval=TRUE, warning=FALSE, message=FALSE}

two.words.names <- all.characters %>%
  str_match(pattern = "[[:upper:]]+ " %R%  rebus::capture("[[:upper:]]+")) %>%
  as_data_frame %>%
  filter(!is.na(V1) & !is.na(V2))

two.words.names

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

repeated.names <- two.words.names[two.words.names$V2 %in% all.characters,]

repeated.names %<>%
  rename(two_words_names = V1,
         one_word_names = V2)

repeated.names

```

All together? I will have to manually check the names! 

What to do with characters such as young Ned?

Do characters appear after they die? If yes, I should be careful. Look at the pattern. I don't think I want to include as participation if they appear after having died.



Try first episode


Try cleaning first episode

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.first.episode <- first.transcript %>%
  str_extract_all(pattern = rebus::or("[[:upper:]]+ [[:upper:]]+:", "[[:upper:]]+:")) %>%
  unlist %>% str_replace_all(pattern = ":", replacement = "") %>% unique %>% sort

```

Check Royce and luwin

```{r eval=TRUE, warning=FALSE, message=FALSE}

two.words.names <- characters.first.episode %>%
  str_match(pattern = "[[:upper:]]+ " %R%  rebus::capture("[[:upper:]]+")) %>%
  as_data_frame %>%
  filter(!is.na(V1) & !is.na(V2))

two.words.names

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

repeated.names <- two.words.names[two.words.names$V2 %in% characters.first.episode,]

repeated.names %<>%
  rename(two_words_names = V1,
         one_word_names = V2)

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

first.transcript %>% print()

```


First try to split each sentence with author

```{r eval=FALSE, warning=FALSE, message=FALSE}


first.transcript.split <- str_split(first.transcript, pattern = capture(rebus::or("\n[[:upper:]]+:","\n[[:upper:]]+ [[:upper:]]+:", "[[:upper:]]+:", "[[:upper:]]+ [[:upper:]]+:")) ) 


```

```{r eval=TRUE, warning=FALSE, message=FALSE}

names.speakers <- str_match_all(first.transcript, pattern = rebus::or("\n[[:upper:]]+:","\n[[:upper:]]+ [[:upper:]]+:", "[[:upper:]]+:", "[[:upper:]]+ [[:upper:]]+:") ) %>%  
  unlist %>%
  str_replace_all(pattern = rebus::or("^[[:cntrl:]]", "[[:punct:]]$"), replacement = "")

first.transcript.split <- str_split(first.transcript, pattern = capture(rebus::or("\n[[:upper:]]+:","\n[[:upper:]]+ [[:upper:]]+:", "[[:upper:]]+:", "[[:upper:]]+ [[:upper:]]+:")) ) %>%
  unlist %>%
  str_replace_all(pattern = rebus::or("\n"), replacement = "")

names.speakers %>% head(20)

first.transcript.split %>% head(6)

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

first.transcript.df <- data_frame(names_speakers = c(NA,names.speakers), 
                                  text = first.transcript.split  )

```


Replace names of repeated authors with short name

```{r eval=TRUE, warning=FALSE, message=FALSE}

first.transcript.df %<>%
  left_join(repeated.names, by = c("names_speakers" = "two_words_names")) %>%
  mutate(names_speakers = if_else(!is.na(one_word_names), 
                                  true = one_word_names,
                                  false = names_speakers)) %>%
  select(-one_word_names)

```


```{r eval=FALSE, warning=FALSE, message=FALSE}

first.transcript.df %>% knitr::kable()

first.transcript.df

```


```{r eval=TRUE, warning=FALSE, message=FALSE}

first.transcript.df %>%
  write_delim("interim_output/first_season_transcript.txt", delim = "|")

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

table(first.transcript.df$names_speakers) %>%
  sort(decreasing = T)

```


