---
title: "Scrap and clean episode transcripts"
output: html_notebook
---

Aim:
* Scrap and clean episode transcripts from genius.com;
* Relate all characters that were scrapped in script '02_scrap_characters_list.Rmd' to those in transcripts.

```{r eval=TRUE, warning=FALSE, message=FALSE}
rm(list = ls())

library(httr)
library(tidytext)
library(knitr)
library(xml2)
library(rebus)
library(stringr)
library(rvest)
library(magrittr)
library(tidyverse)

```


#Import data from previous scripts
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.dead <- readRDS("interim_output/characters.death.long.02.RDS")

characters.all <- readRDS("interim_output/characters.all.02.RDS")

```

#Scrap list of GoT episodes
```{r eval=TRUE, warning=FALSE, message=FALSE}

if(!"episode_list.RDS" %in% list.files("interim_output/")){
  
episode.list <- read_html("https://en.wikipedia.org/wiki/List_of_Game_of_Thrones_episodes")

episode.list %<>%
  html_nodes( ".summary") %>%
  html_text() %>%
  str_replace_all(pattern = rebus::or("[[:punct:]]", "[[:cntrl:]]"),
                  replacement = "")

episode.list %>%
  write_rds("interim_output/episode_list.RDS")

}else{
  
episode.list <- read_rds("interim_output/episode_list.RDS")  
  
}

```

# Scrap GoT transcripts from genius.com
There seem to be two different patterns in the links of genius.com
Ones end with 'script-annotated' and others just with 'annotated'.
e.g. "https://genius.com/Game-of-thrones-episode-annotated" and "https://genius.com/Game-of-thrones-episode-script-annotated"

## Create hypothetical links to transcript websites

```{r eval=TRUE, warning=FALSE, message=FALSE}

links.all.seasons.1 <- episode.list %>%
  tolower() %>%
  str_replace_all(pattern = " ", replacement = "-") %>%
  str_c("https://genius.com/Game-of-thrones", ., "annotated", sep = "-")

links.all.seasons.2 <- episode.list %>%
  tolower() %>%
  str_replace_all(pattern = " ", replacement = "-") %>%
  str_c("https://genius.com/Game-of-thrones", ., "script","annotated", sep = "-")

links.all.seasons.df <- data_frame(link_1 = links.all.seasons.1,
                                   link_2 = links.all.seasons.2)

```


## Check if links are valid 
Not all episodes are transcribed in genius.com webpage!
Spot missing transcribed episodes.
_To update list of transcripts, delete the output of this chunk of code and run it_
```{r eval=TRUE, warning=FALSE, message=FALSE}

if(!"valid_transcript_links.RDS" %in% list.files("interim_output")){

valid.links.1 <- links.all.seasons.df$link_1 %>%
  map_lgl(url_success) 

valid.links.2 <- vector(mode = "logical", length = length(valid.links.1))

valid.links.2[valid.links.1 == F] <- links.all.seasons.df$link_2[valid.links.1 == F] %>%
  map_lgl(url_success)
  
links.all.seasons.df %<>%
  bind_cols(valid_links_1 = valid.links.1,
            valid_links_2 = valid.links.2)

valid.links <- if_else(links.all.seasons.df$valid_links_1 == T,
                       true = links.all.seasons.df$link_1,
                       false = if_else(links.all.seasons.df$valid_links_2 == T,
                                       true = links.all.seasons.df$link_2,
                                       false = "missing episode"))

valid.links %>%
  write_rds(path = "interim_output/valid_transcript_links.RDS")

}else{
  
  valid.links <- read_rds(path = "interim_output/valid_transcript_links.RDS")
  
}

```

**06-10-2017 There seem to be 22 episodes missing!** 
```{r eval=TRUE, warning=FALSE, message=FALSE}

(valid.links == "missing episode") %>% sum()

valid.links

```

## Scrap transcripts
```{r eval=TRUE, warning=FALSE, message=FALSE}

season.vector <- c(str_c("season_", rep(1:6, 10)), rep("season_7", 7)) %>% sort

episode.number.vector <- c(rep(1:10, 6), rep(1:7))

episode.list.df <- data_frame(season = season.vector,
                              episode_number = episode.number.vector,
                              episode_name = episode.list,
                              link = valid.links)

episode.list.df

rm(valid.links, season.vector, episode.number.vector, links.all.seasons.1, links.all.seasons.2,
   links.all.seasons.df)

```

## Convert trantscripts into tidy text
```{r eval=TRUE, warning=FALSE, message=FALSE}

if(!"all_transcripts.RDS" %in% list.files("interim_output/")){

all.transcripts <- episode.list.df$link[which(episode.list.df$link != "missing episode")] %>%
  map(function(x){read_html(x) %>%
  html_nodes(".lyrics p") %>%
  html_text })

 all.transcripts %>% 
   write_rds(path = "interim_output/all_transcripts.RDS")
 
}else{
  
  all.transcripts <- read_rds("interim_output/all_transcripts.RDS")
  
}
 
```


```{r eval=TRUE, warning=FALSE, message=FALSE}

all.transcripts %<>%
  map_chr(function(x){x %>% unlist %>% str_c(collapse = "_") })

episode.list.df$transcript <- NA

episode.list.df$transcript[episode.list.df$link != "missing episode"] <- all.transcripts


```

###Transcripts into readable text
This step is not strictly needed but it helps manual explorations and checks.
**Not finished**
```{r eval=FALSE, warning=FALSE, message=FALSE}

if(!"interim_output/transcripts" %in% list.dirs("interim_output/transcripts")){
  
  dir.create("interim_output/transcripts")
  
}

#for(i in 1:nrow(episode.list.df)){
  
 # episode.list.df
  
#}

trial <- episode.list.df[1:3,] %>% #place a conditional to use only those that have valid transcripts
  transpose() %>%
  map(function(x){ 
    
    x$transcript %>%
      strsplit(split = rebus::or("\n", "." %R% "[[:upper:]]+" ) ) %>%
      unlist() %>% 
      #data_frame() %>% 
      print()
      #write_delim(path = str_c("interim_output/transcripts/","transcript_", x$episode_name, ".txt"),
       #           delim = "\t")
    
      }) 
  

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

rm(all.transcripts)

```

#Spot character names in transcripts
Transcriptions use names both in upper and lower case! 
e.g. 
* https://genius.com/Game-of-thrones-winter-is-coming-annotated
* https://genius.com/Game-of-thrones-the-kingsroad-annotated

Ideally, the pattern used should also be able to capture all names in characters scraped from wikipedia.

There are some transcripts that use \ n pattern, others that don't


Object: characters.all

What about characters that are word + word + word?

There are patterns of NAME (in valerian) e.g:
CERSEI (sighs): Thank you so much for your kind words.

```{r eval=TRUE, warning=FALSE, message=FALSE}

pattern.character.names <- rebus::or("\\.[[:alpha:]]+" %R% rebus::one_or_more(" [[:alpha:]]+") %R% ":",
                                     "\n[[:alpha:]]+" %R% rebus::one_or_more(" [[:alpha:]]+") %R% ":",
                                     "\n[[:alpha:]]+" %R% rebus::zero_or_more(" [[:alpha:]]+") %R% " \\(" %R% rebus::one_or_more(rebus::or("[[:alpha:]]","\\s")) %R% "\\):",
                                     "\\.[[:alpha:]]+" %R% rebus::zero_or_more(" [[:alpha:]]+") %R% " \\(" %R% rebus::one_or_more(rebus::or("[[:alpha:]]","\\s")) %R% "\\):")

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts <- episode.list.df$transcript %>%
  str_extract_all(pattern = pattern.character.names) %>%
  unlist %>% str_replace_all(pattern = rebus::or(":", "\n", "\\.", 
                                                 "\\(" %R% rebus::one_or_more("[[:print:]]") %R% "\\)"), replacement = "") %>% 
  unique %>% 
  sort

rm(pattern.character.names)

#characters.transcripts

```

All characters in transcripts to upper. 
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts %<>%
  toupper() %>% 
  unique

characters.transcripts

```


Careful! This is not the final count. The only purpose here should be to help data cleaning.
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts.df <- data_frame(name = characters.transcripts,
                                count = map_dbl(characters.transcripts, str_count))

characters.transcripts.df
```

Address pattern of 'young' in transctipts.
lady, maester, ser, lord
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts.df %<>%
  mutate(name = name %>% str_replace_all(pattern = rebus::or("LORD ", "MAESTER ",
                                                         "SER ", "YOUNG ",
                                                         "LADY ", "LADYC "),
                                     replacement = "") )

```



In transcripts, many characters appear only with their first name (i.e. last name is excluded). We need to compute the first name of all characters and match the names in transcripts with either first name or full name
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.all.firstname <- characters.all %>%
  str_match(pattern = capture("[[:upper:]][[:lower:]]+") %R% optional(" " %R% "\\w+") %R% " [[:upper:]].+")

# The previous regex fails to capture the first name of characters with names with three or more pieces such as:
# Brienne of Tarth; Hizdahr zo Loraq; Thoros of Myr
# I can do that with another regex.

characters.all.firstname.alternative <-characters.all %>%
  str_match(pattern = capture("[[:upper:]][[:lower:]]+") %R% " .+" %R%  " [[:upper:]].+")

characters.all.df <- data_frame(name_1 = characters.all, 
                                name_2 = characters.all.firstname[,2],
                                name_3 = characters.all.firstname.alternative[,2])

characters.all.df %<>%
  mutate(name_2 = if_else(is.na(name_2),
                          true = name_3,
                          false =name_2 )) %>%
  select(-name_3)

```

Clean characters from transcripts
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts.df %<>%
  filter(!name %in% c("A VOICE", "ALL", "ALL THREE", "ALL TOGETHER",
                      "ANNOUNCER", "ARCHERS", "ATTENDANT", "BANKER",
                      "BLONDE PROSTITUTE", "BOLTON BANNERMAN", "BOLTON OFFICER"))%>%
  mutate(name = name %>% str_replace(pattern = "AERSON", replacement = "AERON") %>%
           str_replace(pattern = rebus::or("ALLITHORNE", "ALLITHRONE", "ALLISTER"), replacement = "ALLISER THORNE") %>%
           str_replace(pattern = rebus::or("BAELISH", "LITTLEFINGER"), replacement = "PETYR BAELISH") %>%
           str_replace(pattern = "BLACK WALDER", replacement = "BLACK WALDER RIVERS") %>%
           str_replace(pattern = "BLACKFISH", replacement = toupper("Brynden Tully")) %>%
           str_replace(pattern = "BRAND", replacement = "BRAN") %>%
           str_replace(pattern = "BRIENNE", replacement = "BRIENNE OF TARTH") %>%
           str_replace(pattern = rebus::or("CASSEL"), replacement = "RODRIK CASSEL") %>%
           str_replace(pattern = rebus::or("DAERNEYS", "DANERYS"), replacement = "DAENERYS") %>%
           str_replace(pattern = rebus::or("DARIO", "DARRIO"), replacement = toupper("Daario Naharis")) %>%
           str_replace(pattern = rebus::or("DOLOROUS EDD", "EDDARDDISON TOLLETT"), replacement = "EDDISON TOLLETT") %>%
           str_replace(pattern = rebus::or(exactly("ED"), exactly("EDD"), exactly("EDDARDD")), replacement = "EDDARD") %>%
           str_replace(pattern = rebus::or("ELARIA", "ELLIA"), replacement = "ELLARIA SAND") %>%
           str_replace(pattern = ("EYED RAVEN"), replacement = "THREE-EYED RAVEN") %>%
           str_replace(pattern = ("GREYWORM"), replacement = "GREY WORM") %>%
           str_replace(pattern = "ROYCE", replacement = "WAYMAR ROYCE") %>%
           str_replace(pattern = rebus::or("PYCELL", "PYRCELLE", "PYCELLEE"), replacement = "PYCELLE") %>%
           str_replace(pattern = "MELISDANDRE", replacement = "MELISANDRE") %>%
           str_replace(pattern = "MHAEGAN", replacement = "MHAEGEN") %>%
           str_replace(pattern = "MOSADOR", replacement = "MOSSADOR") %>%
           str_replace(pattern = "MOUNTAIN", replacement = "GREGOR CLEGANE") %>%
           str_replace(pattern = "OLEANNA", replacement = "OLENNA") %>%
           str_replace(pattern = "OTHELL YARWICK", replacement = "OTHELL YARWYCK") %>%
           str_replace(pattern = rebus::or("SAM", "SAMMY"), replacement = "SAMWELL TARLY") %>%
           str_replace(pattern = "SAAN", replacement = "SALLADHOR SAAN") %>%
           str_replace(pattern = "QYBURNS", replacement = "QYBURN") %>%
           str_replace(pattern = "RAMSEY", replacement = "RAMSAY") %>%
           str_replace(pattern = "ROZ", replacement = "ROS") %>%
           str_replace(pattern = "SLYNT", replacement = "JANOS SLYNT") %>%
           str_replace(pattern = "THE HOUND", replacement = "SANDOR CLEGANE")
           
           )
#OTHELL YARWICK

```
Salladhor Saan

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.transcripts.df$name[!characters.transcripts.df$name %in% 
                                 c(toupper(characters.all.df$name_1), toupper(characters.all.df$name_2))]

```

Optional: export unmatched character names to review them manually.
```{r eval=FALSE, warning=FALSE, message=FALSE}

characters.transcripts.df$name[!characters.transcripts.df$name %in% 
                                 c(toupper(characters.all.df$name_1), toupper(characters.all.df$name_2))] %>%
  as_data_frame %>% 
  write_excel_csv("interim_output/unmatched_names.csv")

```

Check duplicates in 'first name' that could have different 'first name' + 'last name'
```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.all.df %>% head(10)

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

repeated.first.names <- characters.all.df %>%
  count(name_2) %>%
  filter(n > 1)

repeated.first.names

```

**Careful, there are repeated first names and these refer to different characters!**

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.all.df %>%
  filter(name_2 %in% repeated.first.names$name_2, !is.na(name_2)) %>%
  arrange(name_1)

rm(repeated.first.names)

```





Optional: import manually reviewed unmatched character names.
```{r eval=TRUE, warning=FALSE, message=FALSE}

unmatched <- read_delim("interim_output/unmatched_names_MOD.csv",
                        delim = ";") %>%
  filter(not_ignorable == 1) %$%
  value

unmatched

```


```{r eval=TRUE, warning=FALSE, message=FALSE}

map(episode.list.df$transcript, function(x){str_detect(x, pattern = "EDDARDDARDMURE")}) %>% unlist %>% which()

```



```{r eval=TRUE, warning=FALSE, message=FALSE}
stop("Atura't")
```

patterns to remove names: all , prostitute, EVERYBODY EVERYONE

"ALL"              
  [6] "ALL THREE"         "ALL TOGETHER"

"MELISANDRE"       
[191] "MELISDANDRE" MISSANDEI?

"ALLISER"           "ALLISER THORNE"    "ALLISER THRONE"   
 [11] "ALLISTER"
 
 
 "BRAN"              "BRAND"?
 
 CROWD
 
 "DAENERYS"          "DAERNEYS" "DANERYS"  

"DARIO"             "DARRIO" 


"ED"                "EDD"  NED STARK??             

"ELARIA"            "ELLARIA"          
 [86] "ELLIA"   
 
 
 BYSTANDERS
 
 
 GREY WORM  GREYWORM
 
  PLEASE NOTE	(out)  PYCELL PYCELLE
  
  
  QYBURN QYBURNS
  
  
  RAMSAY RAMSEY
  
  
The safest thing to do is to import a list of characters and try to match transcripts to these.
Then remove unmatched characters.

https://en.wikipedia.org/wiki/List_of_Game_of_Thrones_characters








  

Spot repeated character names with two words <- double-check this process
(i.e. they appear with name + lastname or only name)
```{r eval=TRUE, warning=FALSE, message=FALSE}

two.words.names <- all.characters %>%
  str_match(pattern = "[[:upper:]]+ " %R%  rebus::capture("[[:upper:]]+")) %>%
  as_data_frame %>%
  filter(!is.na(V1) & !is.na(V2))

two.words.names

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

repeated.names <- two.words.names[two.words.names$V2 %in% all.characters,]

repeated.names %<>%
  rename(two_words_names = V1,
         one_word_names = V2)

repeated.names

```

All together? I will have to manually check the names! 

What to do with characters such as young Ned?

Do characters appear after they die? If yes, I should be careful. Look at the pattern. I don't think I want to include as participation if they appear after having died.



Try first episode


Try cleaning first episode

```{r eval=TRUE, warning=FALSE, message=FALSE}

characters.first.episode <- first.transcript %>%
  str_extract_all(pattern = rebus::or("[[:upper:]]+ [[:upper:]]+:", "[[:upper:]]+:")) %>%
  unlist %>% str_replace_all(pattern = ":", replacement = "") %>% unique %>% sort

```

Check Royce and luwin

```{r eval=TRUE, warning=FALSE, message=FALSE}

two.words.names <- characters.first.episode %>%
  str_match(pattern = "[[:upper:]]+ " %R%  rebus::capture("[[:upper:]]+")) %>%
  as_data_frame %>%
  filter(!is.na(V1) & !is.na(V2))

two.words.names

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

repeated.names <- two.words.names[two.words.names$V2 %in% characters.first.episode,]

repeated.names %<>%
  rename(two_words_names = V1,
         one_word_names = V2)

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

first.transcript %>% print()

```


First try to split each sentence with author

```{r eval=FALSE, warning=FALSE, message=FALSE}


first.transcript.split <- str_split(first.transcript, pattern = capture(rebus::or("\n[[:upper:]]+:","\n[[:upper:]]+ [[:upper:]]+:", "[[:upper:]]+:", "[[:upper:]]+ [[:upper:]]+:")) ) 


```

```{r eval=TRUE, warning=FALSE, message=FALSE}

names.speakers <- str_match_all(first.transcript, pattern = rebus::or("\n[[:upper:]]+:","\n[[:upper:]]+ [[:upper:]]+:", "[[:upper:]]+:", "[[:upper:]]+ [[:upper:]]+:") ) %>%  
  unlist %>%
  str_replace_all(pattern = rebus::or("^[[:cntrl:]]", "[[:punct:]]$"), replacement = "")

first.transcript.split <- str_split(first.transcript, pattern = capture(rebus::or("\n[[:upper:]]+:","\n[[:upper:]]+ [[:upper:]]+:", "[[:upper:]]+:", "[[:upper:]]+ [[:upper:]]+:")) ) %>%
  unlist %>%
  str_replace_all(pattern = rebus::or("\n"), replacement = "")

names.speakers %>% head(20)

first.transcript.split %>% head(6)

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

first.transcript.df <- data_frame(names_speakers = c(NA,names.speakers), 
                                  text = first.transcript.split  )

```


Replace names of repeated authors with short name

```{r eval=TRUE, warning=FALSE, message=FALSE}

first.transcript.df %<>%
  left_join(repeated.names, by = c("names_speakers" = "two_words_names")) %>%
  mutate(names_speakers = if_else(!is.na(one_word_names), 
                                  true = one_word_names,
                                  false = names_speakers)) %>%
  select(-one_word_names)

```


```{r eval=FALSE, warning=FALSE, message=FALSE}

first.transcript.df %>% knitr::kable()

first.transcript.df

```


```{r eval=TRUE, warning=FALSE, message=FALSE}

first.transcript.df %>%
  write_delim("interim_output/first_season_transcript.txt", delim = "|")

```

```{r eval=TRUE, warning=FALSE, message=FALSE}

table(first.transcript.df$names_speakers) %>%
  sort(decreasing = T)

```


